// Copyright (c) 2025-2026 Maunting Studios
// Licensed under the Business Source License 1.1 - see LICENSE
/**
 * @fileoverview Tests for VaultItemList Component
 */

import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import { render, screen, waitFor } from "@testing-library/react";

import { VaultItemList } from "../VaultItemList";

vi.mock("react-i18next", () => ({
  useTranslation: () => ({
    t: (key: string, fallback?: string) => fallback || key,
  }),
}));

const mockDecryptItem = vi.fn();
const mockEncryptItem = vi.fn();

vi.mock("@/contexts/VaultContext", () => ({
  useVault: () => ({
    decryptItem: (...args: unknown[]) => mockDecryptItem(...args),
    encryptItem: (...args: unknown[]) => mockEncryptItem(...args),
    isDuressMode: false,
  }),
}));

vi.mock("@/contexts/AuthContext", () => ({
  useAuth: () => ({
    user: { id: "user-1" },
  }),
}));

vi.mock("@/services/offlineVaultService", () => ({
  loadVaultSnapshot: vi.fn().mockResolvedValue({
    source: "offline",
    snapshot: {
      vaultId: "vault-1",
      categories: [],
      items: [
        {
          id: "item-ok",
          vault_id: "vault-1",
          title: "Encrypted Item",
          website_url: null,
          icon_url: null,
          item_type: "password",
          is_favorite: false,
          category_id: null,
          created_at: "2026-02-18T10:00:00.000Z",
          updated_at: "2026-02-18T10:00:00.000Z",
          encrypted_data: "cipher-ok",
        },
        {
          id: "item-bad",
          vault_id: "vault-1",
          title: "Encrypted Item",
          website_url: null,
          icon_url: null,
          item_type: "password",
          is_favorite: false,
          category_id: null,
          created_at: "2026-02-18T10:00:00.000Z",
          updated_at: "2026-02-18T09:00:00.000Z",
          encrypted_data: "cipher-bad",
        },
      ],
    },
  }),
  isAppOnline: vi.fn().mockReturnValue(false),
  upsertOfflineItemRow: vi.fn(),
}));

vi.mock("@/components/vault/VaultItemCard", () => ({
  VaultItemCard: ({ item }: { item: { decryptedData?: { title?: string } } }) => (
    <div>{item.decryptedData?.title || "missing-title"}</div>
  ),
}));

describe("VaultItemList", () => {
  let consoleErrorSpy: ReturnType<typeof vi.spyOn>;

  beforeEach(() => {
    vi.clearAllMocks();
    consoleErrorSpy = vi.spyOn(console, "error").mockImplementation(() => {});
    mockEncryptItem.mockResolvedValue("encrypted");
    mockDecryptItem.mockImplementation(async (cipher: string) => {
      if (cipher === "cipher-bad") {
        throw new Error("OperationError");
      }

      return {
        title: "Visible Item",
        itemType: "password",
        isFavorite: false,
        categoryId: null,
      };
    });
  });

  afterEach(() => {
    consoleErrorSpy.mockRestore();
  });

  it("hides undecryptable items from the rendered list", async () => {
    render(
      <VaultItemList
        searchQuery=""
        filter="all"
        categoryId={null}
        viewMode="grid"
        onEditItem={vi.fn()}
      />,
    );

    await waitFor(() => {
      expect(screen.getByText("Visible Item")).toBeInTheDocument();
    });

    expect(screen.queryByText("missing-title")).not.toBeInTheDocument();
  });
});

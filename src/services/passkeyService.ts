// Copyright (c) 2025-2026 Maunting Studios
// Licensed under the Business Source License 1.1 — see LICENSE
/**
 * @fileoverview Passkey Service for SingraPW
 *
 * Client-side WebAuthn integration with PRF extension for
 * zero-knowledge vault unlock via passkeys.
 *
 * Architecture:
 *   Registration (while vault is unlocked, master password available):
 *     1. Get options from server (includes PRF salt)
 *     2. Call startRegistration() with PRF extension
 *     3. If PRF supported: derive wrapping key from PRF output via HKDF
 *     4. Encrypt the raw key bytes (from deriveRawKey) with the wrapping key
 *     5. Send credential + encrypted key to server
 *
 *   Authentication (vault locked):
 *     1. Get options from server (includes PRF salts per credential)
 *     2. Call startAuthentication() with PRF extension
 *     3. Derive wrapping key from PRF output via HKDF
 *     4. Decrypt the raw key bytes → import as non-extractable CryptoKey
 *     5. Vault unlocked — no master password needed
 *
 * SECURITY:
 *   - PRF output (32 bytes) is never stored; only used transiently
 *   - Wrapping key is derived via HKDF-SHA-256 (not raw PRF output)
 *   - Raw key bytes are encrypted with AES-256-GCM (IV || ciphertext || tag)
 *   - The imported CryptoKey is non-extractable (same as password-derived)
 *   - Server never sees the unwrapped encryption key
 *   - PRF salt is generated server-side with CSPRNG
 *   - Raw key bytes are wiped from memory immediately after use
 */

import { startRegistration, startAuthentication, base64URLStringToBuffer } from '@simplewebauthn/browser';
import type {
    PublicKeyCredentialCreationOptionsJSON,
    PublicKeyCredentialRequestOptionsJSON,
    RegistrationResponseJSON,
    AuthenticationResponseJSON,
} from '@simplewebauthn/browser';
import { supabase } from '@/integrations/supabase/client';
import { importMasterKey } from '@/services/cryptoService';

// ============ WebAuthn PRF Extension Types ============
// PRF is a WebAuthn Level 3 extension not yet reflected in
// @simplewebauthn's vendored DOM types, so we define the shapes locally.

/** PRF eval input (salt buffers sent to the authenticator). */
interface PrfEvalInput {
    first: ArrayBuffer;
    second?: ArrayBuffer;
}

/** PRF extension input passed via `extensions.prf`. */
interface PrfExtensionInput {
    eval?: PrfEvalInput;
    evalByCredential?: Record<string, PrfEvalInput>;
}

/** PRF eval output (raw PRF results returned by the authenticator). */
interface PrfEvalOutput {
    first: ArrayBuffer;
    second?: ArrayBuffer;
}

/** PRF extension output returned in `clientExtensionResults.prf`. */
interface PrfExtensionOutput {
    enabled?: boolean;
    results?: PrfEvalOutput;
}

/** Extended client extension inputs including the PRF extension. */
interface ExtensionsWithPrf extends AuthenticationExtensionsClientInputs {
    prf?: PrfExtensionInput;
}

/** Extended client extension outputs including the PRF extension. */
interface ClientExtensionOutputsWithPrf extends AuthenticationExtensionsClientOutputs {
    prf?: PrfExtensionOutput;
}

/** Options JSON with PRF-aware extensions for registration. */
interface CreationOptionsWithPrf extends Omit<PublicKeyCredentialCreationOptionsJSON, 'extensions'> {
    extensions?: ExtensionsWithPrf;
}

/** Options JSON with PRF-aware extensions for authentication. */
interface RequestOptionsWithPrf extends Omit<PublicKeyCredentialRequestOptionsJSON, 'extensions'> {
    extensions?: ExtensionsWithPrf;
}

/** Response JSON with PRF-aware clientExtensionResults. */
interface RegistrationResponseWithPrf extends Omit<RegistrationResponseJSON, 'clientExtensionResults'> {
    clientExtensionResults: ClientExtensionOutputsWithPrf;
}

/** Response JSON with PRF-aware clientExtensionResults. */
interface AuthenticationResponseWithPrf extends Omit<AuthenticationResponseJSON, 'clientExtensionResults'> {
    clientExtensionResults: ClientExtensionOutputsWithPrf;
}

// ============ Constants ============

/**
 * HKDF info string for deriving the wrapping key from PRF output.
 * This ensures domain separation even if PRF output were reused.
 */
const HKDF_INFO = new TextEncoder().encode('SingraPW-PasskeyWrappingKey-v1');

/**
 * Static salt for HKDF. The PRF output already includes the per-credential
 * PRF salt, so the HKDF salt is a fixed domain separator.
 */
const HKDF_SALT = new TextEncoder().encode('SingraPW-HKDF-Salt-v1');

/** AES-GCM IV length in bytes */
const IV_LENGTH = 12;

// ============ Feature Detection ============

/**
 * Checks whether WebAuthn is available in this browser.
 *
 * @returns true if the browser supports WebAuthn
 */
export function isWebAuthnAvailable(): boolean {
    return (
        typeof window !== 'undefined' &&
        typeof window.PublicKeyCredential !== 'undefined' &&
        typeof window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable === 'function'
    );
}

/**
 * Checks whether a platform authenticator (e.g. Windows Hello, Touch ID,
 * Face ID, Android biometrics) is available.
 *
 * @returns true if a platform authenticator is available
 */
export async function isPlatformAuthenticatorAvailable(): Promise<boolean> {
    if (!isWebAuthnAvailable()) return false;
    try {
        return await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
    } catch {
        return false;
    }
}

// ============ Registration ============

/**
 * Registers a new passkey with optional PRF support.
 *
 * Must be called while the vault is unlocked AND the raw key bytes are
 * available (from a recent deriveRawKey call). The raw bytes are encrypted
 * with the PRF-derived wrapping key and stored server-side.
 *
 * @param rawKeyBytes - The raw 32-byte AES key (from deriveRawKey)
 * @param deviceName - User-friendly name for this passkey
 * @returns Result with success status and PRF support indication
 */
export async function registerPasskey(
    rawKeyBytes: Uint8Array,
    deviceName: string = 'Passkey',
): Promise<PasskeyRegistrationResult> {
    // 1. Get registration options from server
    const { data: serverData, error: serverError } = await supabase.functions.invoke('webauthn', {
        body: { action: 'generate-registration-options', displayName: deviceName },
    });

    if (serverError || !serverData?.options) {
        return { success: false, error: serverError?.message || 'Failed to get registration options' };
    }

    const options: PublicKeyCredentialCreationOptionsJSON = serverData.options;
    const prfSalt: string = serverData.prfSalt;

    // 2. Convert PRF salt from base64url to ArrayBuffer
    const prfSaltBytes = base64URLStringToBuffer(prfSalt);

    // 3. Call startRegistration with PRF extension injected
    let regResponse: RegistrationResponseJSON;
    try {
        const optionsWithPrf: CreationOptionsWithPrf = {
            ...options,
            extensions: {
                ...(options.extensions || {}),
                prf: {
                    eval: {
                        first: prfSaltBytes,
                    },
                },
            },
        };
        regResponse = await startRegistration({
            optionsJSON: optionsWithPrf as PublicKeyCredentialCreationOptionsJSON,
        });
    } catch (err: unknown) {
        if (err instanceof Error && err.name === 'NotAllowedError') {
            return { success: false, error: 'CANCELLED' };
        }
        return { success: false, error: err instanceof Error ? err.message : 'Registration failed' };
    }

    // 4. Check if PRF is supported by this authenticator
    const clientExtResults = (regResponse as unknown as RegistrationResponseWithPrf).clientExtensionResults;
    const prfEnabled = clientExtResults?.prf?.enabled === true;

    let wrappedMasterKey: string | null = null;

    if (prfEnabled) {
        // PRF is supported — try to get PRF output from registration
        const prfResults = clientExtResults?.prf?.results;

        if (prfResults?.first) {
            // Got PRF output during registration — wrap the raw key now
            const prfOutput = new Uint8Array(prfResults.first);
            try {
                wrappedMasterKey = await encryptRawKeyBytes(rawKeyBytes, prfOutput);
            } finally {
                prfOutput.fill(0);
            }
        }
        // If no PRF results during registration, we need a separate
        // authentication ceremony. The UI will handle this.
    }

    // 5. Verify registration on the server and store credential
    const { data: verifyData, error: verifyError } = await supabase.functions.invoke('webauthn', {
        body: {
            action: 'verify-registration',
            credential: regResponse,
            deviceName,
            prfSalt,
            wrappedMasterKey,
            prfEnabled,
        },
    });

    if (verifyError || !verifyData?.verified) {
        return { success: false, error: verifyError?.message || 'Server verification failed' };
    }

    return {
        success: true,
        credentialId: verifyData.credentialId,
        prfEnabled,
        needsPrfActivation: prfEnabled && !wrappedMasterKey,
    };
}

/**
 * Completes PRF activation by performing an authentication ceremony
 * to get PRF output and wrap the raw key bytes.
 *
 * Some authenticators only return PRF during get(), not create().
 *
 * @param rawKeyBytes - The raw 32-byte AES key (from deriveRawKey)
 * @returns Success status and the credential ID that was activated
 */
export async function activatePasskeyPrf(
    rawKeyBytes: Uint8Array,
): Promise<{ success: boolean; error?: string; credentialId?: string }> {
    // 1. Get authentication options
    const { data: serverData, error: serverError } = await supabase.functions.invoke('webauthn', {
        body: { action: 'generate-authentication-options' },
    });

    if (serverError || !serverData?.options) {
        return { success: false, error: 'Failed to get authentication options' };
    }

    const options: PublicKeyCredentialRequestOptionsJSON = serverData.options;
    const prfSalts: Record<string, string> = serverData.prfSalts || {};

    // Build PRF extension
    const prfExtension = buildPrfExtension(prfSalts);

    // 2. Call startAuthentication with PRF
    let authResponse: AuthenticationResponseJSON;
    try {
        const optionsWithPrf: RequestOptionsWithPrf = {
            ...options,
            extensions: {
                ...(options.extensions || {}),
                prf: Object.keys(prfExtension).length > 0 ? prfExtension : undefined,
            },
        };
        authResponse = await startAuthentication({
            optionsJSON: optionsWithPrf as PublicKeyCredentialRequestOptionsJSON,
        });
    } catch (err: unknown) {
        if (err instanceof Error && err.name === 'NotAllowedError') {
            return { success: false, error: 'CANCELLED' };
        }
        return { success: false, error: err instanceof Error ? err.message : 'Authentication failed' };
    }

    // 3. Verify on server
    const { data: verifyData, error: verifyError } = await supabase.functions.invoke('webauthn', {
        body: { action: 'verify-authentication', credential: authResponse },
    });

    if (verifyError || !verifyData?.verified) {
        return { success: false, error: 'Verification failed' };
    }

    // 4. Extract PRF output and wrap the key
    const clientExtResults = (authResponse as unknown as AuthenticationResponseWithPrf).clientExtensionResults;
    const prfResults = clientExtResults?.prf?.results;

    if (!prfResults?.first) {
        return { success: false, error: 'PRF output not available' };
    }

    const prfOutput = new Uint8Array(prfResults.first);
    try {
        const wrappedKey = await encryptRawKeyBytes(rawKeyBytes, prfOutput);

        // 5. Update the credential with the wrapped key
        // passkey_credentials is not in generated Supabase types yet
        const { error: updateError } = await (supabase as unknown as { from(table: string): { update(values: Record<string, unknown>): { eq(column: string, value: string): PromiseLike<{ error: Error | null }> } } })
            .from('passkey_credentials')
            .update({ wrapped_master_key: wrappedKey })
            .eq('credential_id', verifyData.credentialId);

        if (updateError) {
            return { success: false, error: 'Failed to save wrapped key' };
        }

        return { success: true, credentialId: verifyData.credentialId };
    } finally {
        prfOutput.fill(0);
    }
}

// ============ Authentication ============

/**
 * Authenticates using a registered passkey and derives the vault
 * encryption key from the PRF output.
 *
 * @returns The unwrapped encryption key on success
 */
export async function authenticatePasskey(): Promise<PasskeyAuthenticationResult> {
    // 1. Get authentication options from server
    const { data: serverData, error: serverError } = await supabase.functions.invoke('webauthn', {
        body: { action: 'generate-authentication-options' },
    });

    if (serverError || !serverData?.options) {
        return { success: false, error: serverError?.message || 'Failed to get authentication options' };
    }

    const options: PublicKeyCredentialRequestOptionsJSON = serverData.options;
    const prfSalts: Record<string, string> = serverData.prfSalts || {};

    // 2. Build PRF extension
    const prfExtension = buildPrfExtension(prfSalts);

    // 3. Call startAuthentication with PRF extension
    let authResponse: AuthenticationResponseJSON;
    try {
        const optionsWithPrf: RequestOptionsWithPrf = {
            ...options,
            extensions: {
                ...(options.extensions || {}),
                prf: Object.keys(prfExtension).length > 0 ? prfExtension : undefined,
            },
        };
        authResponse = await startAuthentication({
            optionsJSON: optionsWithPrf as PublicKeyCredentialRequestOptionsJSON,
        });
    } catch (err: unknown) {
        if (err instanceof Error && err.name === 'NotAllowedError') {
            return { success: false, error: 'CANCELLED' };
        }
        return { success: false, error: err instanceof Error ? err.message : 'Authentication failed' };
    }

    // 4. Verify authentication on the server
    const { data: verifyData, error: verifyError } = await supabase.functions.invoke('webauthn', {
        body: {
            action: 'verify-authentication',
            credential: authResponse,
        },
    });

    if (verifyError || !verifyData?.verified) {
        return { success: false, error: verifyError?.message || 'Server verification failed' };
    }

    // 5. Extract PRF output and unwrap the encryption key
    const clientExtResults = (authResponse as unknown as AuthenticationResponseWithPrf).clientExtensionResults;
    const prfResults = clientExtResults?.prf?.results;

    if (!prfResults?.first || !verifyData.wrappedMasterKey) {
        // Authentication succeeded but no PRF available.
        return {
            success: true,
            prfEnabled: false,
            error: 'NO_PRF',
        };
    }

    // 6. Derive wrapping key from PRF output and decrypt the raw key bytes
    const prfOutput = new Uint8Array(prfResults.first);
    try {
        const rawKeyBytes = await decryptRawKeyBytes(
            verifyData.wrappedMasterKey,
            prfOutput,
        );

        // 7. Import the raw key bytes as a non-extractable CryptoKey
        const encryptionKey = await importMasterKey(rawKeyBytes);

        // SECURITY: Wipe raw key bytes immediately
        rawKeyBytes.fill(0);

        return {
            success: true,
            encryptionKey,
            prfEnabled: true,
            credentialId: verifyData.credentialId,
        };
    } catch (err: unknown) {
        console.error('Failed to unwrap encryption key:', err);
        return { success: false, error: 'Key unwrapping failed — passkey data may be corrupted' };
    } finally {
        prfOutput.fill(0);
    }
}

// ============ Credential Management ============

/**
 * Lists all registered passkeys for the current user.
 *
 * @returns Array of credential summaries
 */
export async function listPasskeys(): Promise<PasskeyCredential[]> {
    const { data, error } = await supabase.functions.invoke('webauthn', {
        body: { action: 'list-credentials' },
    });

    if (error || !data?.credentials) {
        console.error('Failed to list passkeys:', error);
        return [];
    }

    return data.credentials;
}

/**
 * Deletes a registered passkey.
 *
 * @param credentialId - The UUID of the credential record to delete
 * @returns Success status
 */
export async function deletePasskey(
    credentialId: string,
): Promise<{ success: boolean; error?: string }> {
    const { data, error } = await supabase.functions.invoke('webauthn', {
        body: { action: 'delete-credential', credentialId },
    });

    if (error || !data?.deleted) {
        return { success: false, error: error?.message || 'Failed to delete passkey' };
    }

    return { success: true };
}

// ============ PRF Key Wrapping (Internal) ============

/**
 * Derives an AES-256-GCM wrapping key from the PRF output using HKDF-SHA-256.
 *
 * HKDF provides proper domain separation and key stretching:
 *   - Extract: PRF output (32 bytes) + HKDF_SALT -> pseudorandom key
 *   - Expand: PRK + HKDF_INFO -> 256-bit AES key
 *
 * @param prfOutput - Raw 32-byte PRF output from the authenticator
 * @returns CryptoKey suitable for encrypt/decrypt
 */
async function deriveWrappingKey(prfOutput: Uint8Array): Promise<CryptoKey> {
    // Import PRF output as HKDF key material
    const baseKey = await crypto.subtle.importKey(
        'raw',
        prfOutput,
        'HKDF',
        false,
        ['deriveKey'],
    );

    // Derive AES-256-GCM key via HKDF-SHA-256
    return crypto.subtle.deriveKey(
        {
            name: 'HKDF',
            hash: 'SHA-256',
            salt: HKDF_SALT,
            info: HKDF_INFO,
        },
        baseKey,
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt', 'decrypt'],
    );
}

/**
 * Encrypts the raw AES key bytes with a PRF-derived wrapping key.
 *
 * Output format: base64(IV || ciphertext || authTag)
 *
 * @param rawKeyBytes - The raw 32-byte vault encryption key
 * @param prfOutput - Raw 32-byte PRF output
 * @returns Base64-encoded encrypted key
 */
async function encryptRawKeyBytes(
    rawKeyBytes: Uint8Array,
    prfOutput: Uint8Array,
): Promise<string> {
    const wrappingKey = await deriveWrappingKey(prfOutput);
    const iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH));

    const ciphertext = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv, tagLength: 128 },
        wrappingKey,
        rawKeyBytes,
    );

    // Combine IV + ciphertext (includes auth tag appended by AES-GCM)
    const combined = new Uint8Array(iv.length + ciphertext.byteLength);
    combined.set(iv, 0);
    combined.set(new Uint8Array(ciphertext), iv.length);

    return uint8ArrayToBase64(combined);
}

/**
 * Decrypts the raw AES key bytes using a PRF-derived wrapping key.
 *
 * @param encryptedBase64 - Base64-encoded encrypted key (IV || ciphertext || authTag)
 * @param prfOutput - Raw 32-byte PRF output
 * @returns The decrypted raw 32-byte key
 */
async function decryptRawKeyBytes(
    encryptedBase64: string,
    prfOutput: Uint8Array,
): Promise<Uint8Array> {
    const wrappingKey = await deriveWrappingKey(prfOutput);
    const combined = base64ToUint8Array(encryptedBase64);

    const iv = combined.slice(0, IV_LENGTH);
    const ciphertext = combined.slice(IV_LENGTH);

    const plaintext = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv, tagLength: 128 },
        wrappingKey,
        ciphertext,
    );

    return new Uint8Array(plaintext);
}

/**
 * Builds the PRF extension object for startAuthentication.
 * Handles both single and multiple credential scenarios.
 *
 * @param prfSalts - Map of credential_id -> base64url PRF salt
 * @returns PRF extension object for WebAuthn options
 */
function buildPrfExtension(prfSalts: Record<string, string>): Record<string, unknown> {
    const credentialIds = Object.keys(prfSalts);

    if (credentialIds.length === 0) {
        return {};
    }

    if (credentialIds.length === 1) {
        // Single credential: use eval.first directly
        return {
            eval: {
                first: base64URLStringToBuffer(prfSalts[credentialIds[0]]),
            },
        };
    }

    // Multiple credentials: use evalByCredential
    const evalByCredential: Record<string, { first: ArrayBuffer }> = {};
    for (const [credId, salt] of Object.entries(prfSalts)) {
        evalByCredential[credId] = {
            first: base64URLStringToBuffer(salt),
        };
    }
    return { evalByCredential };
}

// ============ Utility Functions ============

/**
 * Converts Uint8Array to Base64 string
 */
function uint8ArrayToBase64(bytes: Uint8Array): string {
    let binary = '';
    for (let i = 0; i < bytes.length; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}

/**
 * Converts Base64 string to Uint8Array
 */
function base64ToUint8Array(base64: string): Uint8Array {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
}

// ============ Type Definitions ============

/**
 * Result of passkey registration
 */
export interface PasskeyRegistrationResult {
    success: boolean;
    error?: string;
    credentialId?: string;
    /** Whether this authenticator supports PRF */
    prfEnabled?: boolean;
    /** If true, PRF is supported but needs a separate auth ceremony to activate */
    needsPrfActivation?: boolean;
}

/**
 * Result of passkey authentication
 */
export interface PasskeyAuthenticationResult {
    success: boolean;
    error?: string;
    /** The unwrapped vault encryption key (only if PRF succeeded) */
    encryptionKey?: CryptoKey;
    /** Whether PRF was used for key derivation */
    prfEnabled?: boolean;
    /** The credential that was used */
    credentialId?: string;
}

/**
 * Passkey credential summary (from server)
 */
export interface PasskeyCredential {
    id: string;
    credential_id: string;
    device_name: string;
    prf_enabled: boolean;
    created_at: string;
    last_used_at: string | null;
}
